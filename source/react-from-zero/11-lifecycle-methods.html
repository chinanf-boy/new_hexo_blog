<!doctype html>

<title>11 Lifecycle Methods - React From Zero</title>

<script src="https://cdn.bootcss.com/react/16.4.0/umd/react.development.js"></script>
<script src="https://cdn.bootcss.com/react-dom/16.4.0-alpha.0911da3/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/create-react-class@15.6.3/create-react-class.js"></script>
<script src="https://cdn.bootcss.com/babel-standalone/7.0.0-beta.3/babel.min.js"></script>

<div id="app"></div>

<script type="text/babel">
// If we use component classes, our components inherit
// a bunch of methods, which get called by React at specific
// times to allow us to get more control over our components
// a few of them we already met in lesson 9
// Here are a few new ones. Not all of them, but the most important ones
// 让我们对我们的组件有更多的控制,其中一些我们已经在第9课中遇到过. 这里有几个新组件. 不是全部,而是最重要的
var TRANSLATION_FROM_SOMEWHERE = "Text from a synchronous source."

var MyComponent = createReactClass({
  // This method is for default prop values
  // it gets called before the props are given to our component
  // the "real" props override them if there are any
  // 这个方法是在默认的prop值之前被调用的`props`给我们的组件"真实"`props`如果有的话,覆盖它们
  getDefaultProps: function() {
    return {
      iGetOverriden: "default",
      iStayAsIAm: "default",
    }
  },

  // This method is called before a component got mounted to the DOM
  // it returns values that are used for this.state
  // 这个方法在组件被装载到DOM之前被调用,它返回用于的值`this.state`
  getInitialState: function() {
    return {serverData: null}
  },

  // This method gets called right before the component is mounted
  // can be used to initialize some synchronous configuration, that should
  // be available before the component renders
  // 在装载组件之前调用此方法可用于初始化某些同步配置,该配置在组件呈现前应该可用
  componentWillMount: function() {
    this.TEXT = TRANSLATION_FROM_SOMEWHERE
  },

  // This method will be called right after the component got mounted
  // it's a good place to start some asynchronous tasks.
  // For example on the first mount it shows a loading message
  // then componentDidMount is called and gets some server data.
  // 这个方法在组件被挂载后立即调用,这是启动一些异步任务的好地方. 例如,在第一个mount上显示一个加载消息,然后调用componentDidMount并获取一些服务器数据.
  componentDidMount: function() {

    var component = this

    // We clean up the data and get new from somewhere
    // 我们清理数据并从某处获得新的信息
    function loadData() {

      component.setState({serverData: null})

      getServerData(function(data) {
        component.setState({serverData: data})
      })

    }

    // Initial data load
    // 初始数据加载
    loadData()

    // We simulate a server request every 4 seconds
    // 我们每4秒模拟一次服务器请求
    this.updateInterval = setInterval(loadData, 4000)

  },

  // This method will be called before the component gets removed from the DOM
  // a bit like a destructor. Here we can do some cleanup.
  // 这个方法在组件从析构函数中被移除之前被调用. 在这里,我们可以做一些清理.
  componentWillUnmount: function() {

    clearInterval(this.updateInterval)

  },

  // This method is called before a render when new props or state is available
  // it won"t be called on the first render or if this.forceUpdate() is used
  // it can be used if some state or prop changes don"t require a rerender
  // 新方法在渲染之前调用此方法`props`或状态是可用的,它不会在第一个渲染或如果调用`this.forceUpdate()`如果某些状态或道具变化不需要重投,可以使用它
  shouldComponentUpdate: function(nextProps, nextState) {

    // we want to render on every change, this is the default behaviour
    // 我们想要在每次更改时渲染,这是默认行为
    return true

  },

  render: function() {
    return (
      <h2 style={{width: 400, margin: "auto"}}>

        Overriden Prop: {this.props.iGetOverriden}<br/><br/>

        Default Prop: {this.props.iStayAsIAm}<br/><br/>

        {this.TEXT}<br/><br/>

        {this.state.serverData
          ? this.state.serverData
          : "Loading..."
        }
      </h2>
    )
  },

})

function getServerData(fn) {
  setTimeout(function() { fn("Data Loaded!") }, 700)
}

ReactDOM.render(<MyComponent iGetOverriden={"override"}/>, document.getElementById("app"))
</script>
