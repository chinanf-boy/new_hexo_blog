<!doctype html>

<title>09 Component Classes - React From Zero</title>

<script src="https://cdn.bootcss.com/react/16.4.0/umd/react.development.js"></script>
<script src="https://cdn.bootcss.com/react-dom/16.4.0-alpha.0911da3/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/prop-types@15.6.1/prop-types.js"></script>
<script src="https://cdn.bootcss.com/babel-standalone/7.0.0-beta.3/babel.min.js"></script>

<script src="https://unpkg.com/create-react-class@15.6.3/create-react-class.js">
// React.createClass was removed from React 16 and is now its own package
// `React.createElement()`reateClass已从中删除`React`16现在是它自己的软件包
</script>

<div id="app"></div>

<script type="text/babel">
// Often a component needs to maintain some internal state
// for example if there is an interaction involved
// in this case a component function is not sufficient
// the component function can only have properties and no state
// we need a component class with a render function
// 通常情况下,组件需要维护一些内部状态,例如,如果在这种情况下涉及交互,则组件功能不够,组件功能只能具有属性而没有状态,我们需要具有渲染功能的组件类
var MyComponent = createReactClass({

  // used for type-checking of the properties
  // same as with the component function
  // 用于与组件函数相同的属性类型检查
  propTypes: {
    color: PropTypes.string,
  },

  // this method sets default values for missing properties
  // it will be called by React
  // before the components gets mounted into the DOM
  // 此方法为缺少的属性设置默认值,它将被调用`React`在组件被装入DOM之前
  getDefaultProps: function() {
    return {color: "green"}
  },

  // this method sets the initial state for the component
  // it will be called by React
  // before the components gets mounted into the DOM
  // if this method is missing, this.state will be undefined
  // 这个方法为它将被调用的组件设置初始状态`React`如果缺少这种方法,组件被装入DOM之前,`this.state`将是未定义的
  getInitialState: function() {
    // The state can be any JavaScript value, often it is an object
    // 国家可以是任何`JavaScript`价值,往往是一个对象
    return {times: 0}
  },

  // this method handles all the clicks on the <span> element
    // 此方法处理所有的点击`<span>`元件
  handleClick: function() {
    // setState() can be called with an object that contains the new state
    // normally this triggers a call of render(), but React can batch multiple
    // calls and defer the render() call (make the call asynchronous)
    // To prevent this, setState can take a callback instead
    // 可以使用包含新状态的对象调用setState () ,但通常会触发render () 的调用`React`可以批量多次调用并延迟render () 调用 (使调用异步) 为了防止出现这种情况,setState可以取回一个回调

    // This can lead to unexpected behaviour, if we rely on this.state or
    // this.props for our calculations
    // this.setState({times: this.state.times + 1})
    
//如果我们依赖,这可能会导致意想不到的行为`this.state`要么`this.props`为我们的计算`this.setState` ({时间: `this.state.times`+ 1}) 
    // The callback version doesn't have this problem
    // The callback gets the right state and props at time of the update
    // 回调版本没有这个问题回调得到正确的状态和`props`在更新时
    this.setState(function(prevState, props) {
      return {times: prevState.times + 1}
    })

  },

  // this method will be called by React
  // after the component got mounted into the DOM
  // also every time this.setState() was called
  // it's like the component function from before
  // but without a props argument
  // 这个方法会被调用`React`每次将组件装入DOM之后`this.setState` () 被称为它就像之前的组件函数,但没有`props`论据
  render: function() {

    // using the prop given by the creator of this component
    // properties are now in this.props instead of the props argument
    // 使用该组件属性的创建者给出的道具现在处于`this.props`而不是`props`论据
    var style = {color: this.props.color}

    // returning an element with a click-handler and the props and
    // state values. state is stored in this.state
    //通过点击处理程序返回一个元素`props`和状态值. 状态存储在`this.state`
    return (
      <span onClick={this.handleClick} style={style}>
        Clicked {this.state.times} times
      </span>
    )

  },

})

// creating some instances of the interactive stateful component class
// one with default color
// Everything works exactly like with the simpler component functions
// The interface has not changed for the user of this component
// 创建一些具有默认颜色的交互式有状态组件类的实例一切与更简单的组件函数完全相同对于此组件的用户,接口没有改变
var reactElement =
  <div>
    <MyComponent color="red"/>
    <br/>
    <MyComponent color="blue"/>
    <br/>
    <MyComponent/>
  </div>;

var renderTarget = document.getElementById("app")

ReactDOM.render(reactElement, renderTarget)
</script>
